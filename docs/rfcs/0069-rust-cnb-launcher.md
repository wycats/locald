# Rust Implementation of CNB Launcher

- Feature Name: `rust_cnb_launcher`
- Start Date: 2025-12-08
- RFC PR: (leave empty)
- Issue: (leave empty)
- Persona: [Terence](../../design/personas.md#4-the-platform-engineer-terence)

## Summary

Create a clean-sheet Rust implementation of the Cloud Native Buildpacks (CNB) `launcher` binary. This tool serves as the entrypoint for OCI images built using Buildpacks, responsible for the final stage of the lifecycle: transitioning from the container runtime into the user's application.

## Motivation

The current reference implementation of the CNB lifecycle is written in Go. While robust, there is a desire within the ecosystem to explore a Rust-based implementation.

- **Performance**: A Rust implementation can potentially offer faster startup times compared to the existing Go implementation, which is critical for scale-to-zero and serverless use cases.
- **Safety**: Rust's type system and error handling can provide more robust parsing of configuration and environment variable logic.
- **Ecosystem**: As more CNB tooling (like `libcnb.rs`) moves to Rust, having a Rust-based launcher aligns with the ecosystem direction.
- **Size**: A stripped Rust binary can be very small, reducing the overhead in the final application image.
- **Independence**: This will be a standalone binary, not coupled to `locald`'s internal codebase, making it reusable by any CNB platform.

## Guide-level explanation

The `launcher` is a binary placed at `/cnb/lifecycle/launcher` inside the container. When the container starts, this binary is executed as `PID 1` (or the effective entrypoint).

Its workflow is:

1.  **Analyze Context**: Look at the arguments passed to the container and the `CNB_PROCESS_TYPE` environment variable.
2.  **Load Configuration**: Read `/cnb/lifecycle/launch.toml` to find defined process types (e.g., `web`, `worker`) and their commands.
3.  **Setup Environment**:
    - Iterate through all buildpack layers.
    - Apply environment variable modifications defined in `<layer>/env` and `<layer>/env.launch`.
    - Handle logic for `append`, `prepend`, `override`, and `default` operations.
4.  **Run Profile Scripts**: Execute any scripts found in `<layer>/profile.d`.
5.  **Exec**: Replace the launcher process with the target application process using `execve`.

## Reference-level explanation

### 1. Configuration Parsing

The launcher must parse `/cnb/lifecycle/launch.toml`. This file is generated by the `exporter` phase of the lifecycle.

```toml
[[processes]]
type = "web"
command = ["python"]
args = ["app.py"]
direct = false

[[processes]]
type = "worker"
command = ["celery"]
args = ["-A", "app", "worker"]
```

It must also support the legacy `metadata.toml` for older buildpacks if backward compatibility is desired.

### 2. Process Type Resolution

The launcher determines what to run based on the following precedence:

1.  **Explicit Command**: If the user passes arguments (e.g., `docker run my-image echo hello`), those are executed directly.
2.  **CNB_PROCESS_TYPE**: If this env var is set (e.g., `web`), look up that process type in `launch.toml`.
3.  **Default Process Type**: If defined in `launch.toml` (or via `CNB_DEFAULT_PROCESS_TYPE`), use that.

### 3. Environment Assembly

This is the most complex part. The launcher must traverse the layer directories:
`/layers/<buildpack-id>/<layer-name>/`

It looks for two subdirectories:

- `env/`: Environment variables applied at build and launch time.
- `env.launch/`: Environment variables applied only at launch time.

Inside these directories, files represent env vars:

- `VAR_NAME`: Content is the value. (Override)
- `VAR_NAME.override`: Content is the value.
- `VAR_NAME.default`: Set only if not already set.
- `VAR_NAME.append`: Append to existing value.
- `VAR_NAME.prepend`: Prepend to existing value.
- `VAR_NAME.delim`: Delimiter for append/prepend.

The launcher must construct the final environment map by applying these rules in the correct order (buildpack order).

### 4. Profile Scripts (`profile.d`)

The launcher must execute scripts in `/layers/.../profile.d/*`.
Since the launcher is a binary, it cannot "source" scripts into itself.
**Strategy**:

- Construct a shell command that sources all profile scripts and then `exec`s the final command.
- **Note**: The CNB spec guarantees that `/bin/sh` is available in the run image, so the implementation can rely on it to source scripts.
- Example: `/bin/sh -c '. script1.sh; . script2.sh; exec "$@"' -- <final-command>`

### 5. Execution

Use the `nix` or `libc` crate to call `execve`. This replaces the launcher process with the application process, ensuring signals are received correctly and no extra PID is consumed.

## Implementation Steps

1.  **Project Setup**: Create a new Rust binary project `cnb-launcher`. This should be a separate crate, potentially in its own repository or a workspace member.
2.  **Config Parser**: Implement `launch.toml` parsing using `serde` and `toml`.
3.  **Env Logic**: Implement the environment variable merging logic. This should be unit-tested heavily with various combinations of override/append/default.
4.  **Process Resolver**: Implement the logic to decide _what_ to run (user args vs. process type).
5.  **Shell Integration**: Implement the `profile.d` sourcing strategy.
6.  **Syscall Interface**: Implement the `execve` call.
7.  **Compliance Testing**: Validate against the [CNB Platform Spec](https://github.com/buildpacks/spec/blob/main/platform.md#launcher).

## Drawbacks

- **Complexity**: The environment variable merging logic is subtle and easy to get wrong.
- **Compatibility**: Must ensure 100% compatibility with the Go implementation to avoid breaking existing buildpacks.

## Rationale and alternatives

- **Go Implementation**: The current standard. It works, but we want the benefits of Rust (safety, size, speed).
- **Shell Script**: A launcher could be a shell script, but parsing TOML and handling complex env merging in shell is fragile and slow.

## Unresolved questions

- **Windows Support**: CNB supports Windows containers. This RFC focuses on Linux containers (which `locald` uses). Windows support is out of scope for this initial implementation but would be required for full feature parity with the standard CNB lifecycle.
