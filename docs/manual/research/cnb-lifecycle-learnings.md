h# Research: CNB Lifecycle & Dev Environments

## Overview

This document tracks learnings from experimenting with the Cloud Native Buildpacks (CNB) `lifecycle` binaries directly on the host ("Native Platform" approach), with the goal of enabling `locald build` and predictable dev environments.

## The "Native Platform" Approach

We are running the `lifecycle` binaries (`detector`, `analyzer`, `builder`, `exporter`, `launcher`) directly on the host OS, rather than inside a Docker container.

### Key Findings

1.  **Binaries**: The `lifecycle` release (e.g., `v0.20.19`) contains all necessary binaries.
2.  **Builder Image Extraction**: To run without Docker, we need the buildpacks and configuration from a builder image (e.g., `heroku/builder:22`). We extracted `/cnb` from the image to `./builder-data/cnb`.
3.  **OCI Layout Export**:
    - The `exporter` can export to an OCI Layout directory instead of a Docker daemon using `-layout` and `-layout-dir`.
    - **Requirement**: `CNB_EXPERIMENTAL_MODE=warn` must be set.
    - **Requirement**: `CNB_PLATFORM_API` must be set (e.g., `0.12`).
    - **Issue**: The `exporter` requires a valid `run-image` reference with a digest (e.g., `ubuntu@sha256:...`) even when exporting to layout. The `analyzer` phase usually resolves this.
4.  **Skipping Phases**:
    - For a local dev environment (just running the app), we might not need the `export` phase (which creates the image).
    - The `build` phase produces the `layers` directory, which contains the installed tools (Node.js, etc.) and the `launch.toml`.
    - This `layers` directory is sufficient to run the application using the `launcher`.

## Dev Environments & DevContainers

The goal is to use the build layers to create predictable dev environments.

### Concept

Instead of just building an image for deployment, we use the CNB detection and build process to provision the local environment.

- **Input**: Source code.
- **Process**: CNB Detect -> CNB Build (installs runtimes/dependencies into `./layers`).
- **Output**: A shell environment where tools (e.g., `node`, `npm`) are in `$PATH` and configured correctly.

### Connection to DevContainers

Standard DevContainers use a `Dockerfile` to build an environment.
By using CNB:

1.  We avoid writing the `Dockerfile`.
2.  We can potentially _generate_ a DevContainer configuration that mounts the CNB layers.
3.  Or, `locald` can act as the "DevContainer runtime" by spawning a shell with the `launcher` environment.

## Technical Details

### The `launcher`

The `launcher` binary is the entrypoint for the application.

- It reads `<layers>/launch.toml`.
- It sets up environment variables defined by buildpacks (e.g., `PATH`, `LD_LIBRARY_PATH`).
- It can run the default process-type (e.g., `web`) or an arbitrary command.
- **Usage**: `launcher <command>` (e.g., `launcher bash`).

### Directory Structure (Prototype)

- `app/`: Source code.
- `layers/`: Generated layers (Node.js, NPM, etc.).
- `platform/`: Platform configuration (env vars).
- `builder-data/`: Extracted buildpacks.

### Current Status

- **Detect**: Works.
- **Build**: Works (Node.js installed).
- **Export**: Failing (Run image reference issue), but might be unnecessary for "Dev Environment" goal.
- **Launch**: Verified.

### Launcher Verification (Success)

- **Experiment**: Ran `launcher bash -c "node -v"` using the layers generated by the `build` phase (skipping `export`).
- **Result**: Success! The `launcher` correctly set up the environment variables (PATH, etc.) and `node` was available.
- **Implication**: We can provide a "Dev Environment" simply by running `detect` -> `build` -> `launcher shell`. No Docker image or OCI export is required.
- **Note**: The top-level `launch.toml` was missing (likely because `export` was skipped), but `launcher` still worked, presumably by reading buildpack-specific layers.

### Cross-Platform Compatibility

- **Question**: Does the "Native Platform" approach work on macOS or Windows?
- **Answer**: **No**, not directly.
- **Reason 1 (Binaries)**: The `lifecycle` binaries are primarily distributed for Linux (and Windows containers, but less common). macOS binaries are not standard.
- **Reason 2 (Stack/Buildpacks)**: Standard buildpacks (e.g., `heroku/builder:22`) target Linux stacks (Ubuntu). They download Linux binaries (ELF format) and expect Linux system libraries (glibc). These will not run on macOS or Windows hosts.
- **Implication**: The "Native Platform" approach is a **Linux-only optimization**.
- **Strategy**:
  - **Linux**: Use "Native Platform" (run lifecycle on host) for speed and simplicity.
  - **macOS/Windows**: Must use a containerized approach (run lifecycle inside Docker/Podman) to provide the necessary Linux environment. `locald` should abstract this difference.

### Non-Docker Alternatives for macOS/Windows

- **Question**: Can we run in a container on macOS/Windows _without_ Docker?
- **Windows (WSL2)**:
  - **Yes**. WSL2 provides a real Linux kernel.
  - `locald` running inside WSL2 is effectively running on Linux.
  - The "Native Platform" approach (running `lifecycle` binaries directly) **works** in WSL2.
- **macOS**:
  - **No**, not natively. macOS (Darwin) cannot run Linux binaries (ELF) directly.
  - **Alternatives to Docker Desktop**:
    - **Podman**: Can run containers (and thus the lifecycle) without a daemon, but still requires a VM on macOS (Podman Machine).
    - **Lima / Colima**: Lightweight Linux VMs. `locald` could run _inside_ the VM, or orchestrate it.
    - **OrbStack**: Another lightweight VM/Container engine.
  - **Conclusion**: On macOS, some form of **Virtualization** is strictly required to provide the Linux kernel. It doesn't have to be "Docker Desktop" (the product), but it must be a Linux VM.

### Lima & Colima Details

- **Lima ("Linux Machines")**:
  - **What it is**: A tool to launch Linux VMs on macOS with automatic file sharing and port forwarding.
  - **Analogy**: "WSL2 for macOS".
  - **Role**: It provides the raw Linux environment (kernel) needed to run Linux binaries (like CNB lifecycle).
  - **Usage**: `limactl start` creates a VM. You can then `lima <command>` to run commands inside it.
- **Colima ("Containers on Lima")**:
  - **What it is**: A higher-level tool built on top of Lima.
  - **Goal**: Drop-in replacement for Docker Desktop.
  - **Role**: It manages a Lima VM pre-configured with Docker or Containerd.
  - **Usage**: `colima start`. It exposes the standard Docker socket, so `docker` commands just work.
- **Integration Strategy**:
  - **If Colima is present**: `locald` can treat it as a standard Docker host. We use the Docker-based CNB lifecycle (wrapping `pack` or using `lifecycle` in a container).
  - **If Lima is present**: `locald` could potentially orchestrate a lightweight "locald-vm" using `limactl` to run the "Native Platform" lifecycle inside it, avoiding the overhead of a full Docker daemon if desired.

### Embedding Virtualization (Rust)

- **Goal**: Embed a Linux VM capability directly into `locald` to avoid external dependencies (like Docker/Lima) on macOS/Windows.
- **Findings**:
  - **macOS**:
    - **`virt-fwk`**: Rust bindings for Apple's `Virtualization.framework`. This allows booting Linux kernels directly.
    - **Complexity**: High. We would need to bundle a Linux kernel and initrd, and manage the VMM logic (networking, file sharing via virtio-fs).
  - **Windows**:
    - **`hyperlight` (Microsoft)**: A new Rust library for embedding microVMs (using Hyper-V or KVM). Designed for "functions at scale", but potentially usable.
    - **`OpenVMM`**: Another Rust-based VMM for Windows/Linux.
  - **Cross-Platform**:
    - **`crosvm`**: ChromeOS VMM (Rust). Supports KVM (Linux) and potentially others, but complex to integrate.
    - **`firecracker`**: Linux/KVM only.
- **Conclusion**:
  - "Embedding" a VMM is possible but is a **major engineering effort**. It involves building a custom VMM (like a mini-Lima) inside `locald`.
  - **Recommendation**: For now, stick to **orchestrating** external tools (Lima, Docker, WSL2).
  - **Future**: If `locald` becomes very popular, building a dedicated "locald-vm" crate using `virt-fwk` (macOS) and `hyperlight` (Windows) could provide a seamless "zero-dep" experience.

### Embedded Lima Strategy (Recommended)

- **Concept**: Instead of asking the user to "brew install lima", `locald` downloads and manages a private copy of the `lima` binary.
- **Feasibility**:
  - **Binaries**: Lima provides pre-compiled binaries for macOS (ARM64/x86_64) and Linux.
  - **Dependencies**:
    - **macOS 13.5+**: Lima defaults to `vz` (Virtualization.framework), which is built-in. **No QEMU required.**
    - **Older macOS**: Requires QEMU. We can choose to only support `vz` for the "embedded" experience, or require QEMU installation for older OSs.
  - **Networking**: Lima's default "user-mode" networking (slirp/user-v2) works without `sudo`.
- **Workflow**:
  1.  `locald` checks for `~/.local/share/locald/tools/lima/bin/limactl`.
  2.  If missing, downloads the tarball from GitHub Releases, verifies checksum, and extracts.
  3.  `locald` generates a `locald-vm.yaml` config (using `vmType: vz` and `mounts: [project_dir]`).
  4.  `locald` runs `limactl start locald-vm.yaml`.
  5.  `locald` wraps `lima` commands to run the CNB lifecycle inside the VM.
- **Pros**:
  - "It just works" experience for the user.
  - No global dependencies.
  - Leverages native macOS virtualization (`vz`) automatically.

### 6. Isolation & Safety (Linux)

- **The Concern**: Running `lifecycle` binaries directly on the host ("Native Platform") lacks isolation.
  - **Filesystem**: Buildpacks could accidentally write outside the workspace/layers directories.
  - **Environment**: Host environment variables might leak in; buildpack env vars might leak out (though we control the process env).
  - **Privilege**: Buildpacks run as the user. A malicious buildpack could access user data.
- **Mitigation Strategies**:
  1.  **Bubblewrap (`bwrap`)**:
      - Lightweight, unprivileged sandboxing.
      - Can bind-mount the workspace and layers, hiding the rest of `$HOME`.
      - Commonly available on Linux distros.
  2.  **Embed `libcontainer` (Rust)**:
      - **Concept**: Use the `libcontainer` crate (from the [Youki](https://github.com/containers/youki) project) to create OCI-compliant containers directly from Rust code.
      - **Pros**: True container isolation (namespaces, cgroups) without an external daemon or `runc` binary. "Zero-dependency" (compiled in).
      - **Cons**: Requires root (usually) or user namespaces (rootless) setup, which can be tricky to get right.
  3.  **External Runtime (`runc` / `crun`)**:
      - Orchestrate a standard OCI runtime.
- **Recommendation**:
  - Start with **"Native Platform" (Process Isolation)** for Phase 34. It's the simplest path to value.
  - If isolation becomes a problem (or for "Untrusted" mode), we can introduce **Embedded `libcontainer`** or `bwrap`. The `libcontainer` crate makes this feasible in Rust without needing Go.

## Decision: Hybrid Strategy

1.  **Linux**: Use "Native Platform" (run `lifecycle` on host).
    - _Future Upgrade_: Wrap in `libcontainer` (Rust) for isolation if needed.
2.  **macOS**: Use "Embedded Lima" (download `lima`, run `lifecycle` in VM).
3.  **Windows**: Use WSL2 (treat as Linux).

This avoids the "Docker Desktop" requirement while keeping complexity manageable.

### 7. Spec Comparison (Platform API 0.14)

- **Phase Ordering**: The spec mandates `analyzer` -> `detector` -> `restorer` -> `builder` -> `exporter`. Our initial assumption of `detect` first was incorrect. `analyzer` runs first to retrieve metadata from the previous image (if any).
- **Exporter Dependency**: The `exporter` relies on `analyzed.toml` generated by the `analyzer`. Skipping `analyzer` (or failing to provide it with valid inputs) causes the `exporter` to fail due to missing `run-image` information.
- **Layout Support**: The spec confirms `[-layout]` is an experimental feature supported by `analyzer` and `exporter`, validating our "Registry-less" approach.
- **Launcher**: The spec explicitly defines the `launcher`'s role in sourcing `profile.d` and setting environment variables, confirming its suitability for "Dev Environments".
